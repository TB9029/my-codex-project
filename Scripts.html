<script>
  (() => {
    const state = {
      currentView: 'dashboard',
      dashboard: null,
      masters: [],
      constants: [],
      tags: [],
      searchResults: [],
      offlineQueue: loadQueue(),
      lastScanTime: 0,
      camera: {
        reader: null,
        stream: null,
        deviceId: null,
        gs1Mode: true,
        hints: null,
        frameCanvas: null,
        frameContext: null,
        roiCanvas: null,
        roiContext: null,
        rotateCanvas90: null,
        rotateContext90: null,
        rotateCanvas270: null,
        rotateContext270: null
      },
      scan: {
        stage: 'idle',
        hintTimer: null,
        overlayTimer: null,
        resetTimer: null,
        frameHandle: null,
        frameTimer: null,
        frameAttempts: 0
      }
    };

    const els = {
      views: document.querySelectorAll('.view'),
      navButtons: document.querySelectorAll('button.nav-btn[data-target]'),
      searchInput: document.getElementById('global-search'),
      searchClear: document.getElementById('search-clear'),
      searchResults: document.getElementById('search-results'),
      badgeExpired: document.getElementById('badge-expired'),
      badgeLt1m: document.getElementById('badge-lt1m'),
      badgeLt2m: document.getElementById('badge-lt2m'),
      recentScans: document.getElementById('recent-scans'),
      masterForm: document.getElementById('master-form'),
      masterFormMessage: document.getElementById('master-form-message'),
      masterList: document.getElementById('master-list'),
      masterSearch: document.getElementById('master-search'),
      masterTagFilter: document.getElementById('master-tag-filter'),
      masterDialog: document.getElementById('master-dialog'),
      masterEditForm: document.getElementById('master-edit-form'),
      masterDelete: document.getElementById('master-delete'),
      masterExport: document.getElementById('master-export'),
      masterImport: document.getElementById('master-import'),
      constantsBody: document.getElementById('constants-body'),
      constantsImport: document.getElementById('constants-import'),
      constantsExport: document.getElementById('constants-export'),
      constantsDeficit: document.getElementById('constants-deficit'),
      refreshButtons: document.querySelectorAll('[data-action="refresh-dashboard"]'),
      queueList: document.getElementById('queue-list'),
      flushQueue: document.getElementById('flush-queue'),
      manualCode: document.getElementById('manual-code'),
      manualSubmit: document.getElementById('manual-submit'),
      resultCard: document.getElementById('scan-result'),
      networkStatus: document.getElementById('network-status'),
      toast: document.getElementById('toast'),
      cameraPreview: document.getElementById('camera-preview'),
      cameraOverlay: document.getElementById('camera-overlay'),
      scanPlaceholder: document.getElementById('scan-placeholder'),
      scanStatus: document.getElementById('scan-status-text'),
      scanHint: document.getElementById('scan-hint'),
      gs1ModeToggle: document.getElementById('toggle-gs1-mode'),
      gs1ModeLabel: document.getElementById('gs1-mode-label'),
      tabButtons: document.querySelectorAll('.tab-btn'),
      tabPanels: document.querySelectorAll('.tab-panel')
    };

    const GS1_FNC1 = String.fromCharCode(29);
    // Common GS1 application identifiers derived from GS1 specs and community parsers
    // such as https://github.com/tony-xlh/GS1-Barcode-Reader.
    const GS1_AI_SPECS = {
      '00': { length: 18, key: 'sscc', label: 'SSCC' },
      '01': { length: 14, key: 'gtin', label: 'GTIN' },
      '02': { length: 14, key: 'gtinContent', label: 'GTIN(å†…è£…)' },
      '10': { variable: true, min: 1, max: 20, key: 'lot', label: 'ãƒ­ãƒƒãƒˆ' },
      '11': { length: 6, key: 'productionDate', type: 'date', label: 'è£½é€ æ—¥' },
      '13': { length: 6, key: 'packDate', type: 'date', label: 'åŒ…è£…æ—¥' },
      '15': { length: 6, key: 'bestBefore', type: 'date', label: 'è³å‘³æœŸé™' },
      '17': { length: 6, key: 'expiry', type: 'date', label: 'æœŸé™' },
      '20': { length: 2, key: 'variant', label: 'ãƒãƒªã‚¢ãƒ³ãƒˆ' },
      '21': { variable: true, min: 1, max: 20, key: 'serial', label: 'ã‚·ãƒªã‚¢ãƒ«' },
      '30': { variable: true, min: 1, max: 8, key: 'count', label: 'æ•°é‡' },
      '37': { variable: true, min: 1, max: 8, key: 'countEach', label: 'å†…åŒ…æ•°' },
      '90': { variable: true, min: 1, max: 30, key: 'internal', label: 'å†…éƒ¨ã‚³ãƒ¼ãƒ‰' }
    };

    function init() {
      bindNav();
      bindTabs();
      bindSearch();
      bindMasterForm();
      bindMasterList();
      bindMasterCsv();
      bindConstantsCsv();
      bindQueueControls();
      bindManualInput();
      bindScanControls();
      bindNetworkEvents();
      prepareScanCanvases();
      window.addEventListener('resize', syncOverlaySize);
      if (els.cameraPreview) {
        els.cameraPreview.addEventListener('loadedmetadata', syncOverlaySize);
      }
      renderQueue();
      loadBootstrap();
      switchView('dashboard');
      setScanStage('idle');
    }

    function loadBootstrap() {
      google.script.run
        .withSuccessHandler(data => {
          state.dashboard = data.dashboard;
          state.masters = data.masters.items || [];
          state.constants = data.constants.items || [];
          state.tags = collectTags(state.masters);
          renderDashboard();
          renderMasterList();
          renderConstants();
          populateTagFilter();
        })
        .withFailureHandler(showError)
        .getAppBootstrap();
    }

    function bindNav() {
      els.navButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.target;
          if (target) {
            switchView(target);
          }
        });
      });
    }

    function bindTabs() {
      els.tabButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const tab = btn.dataset.tab;
          els.tabButtons.forEach(b => b.classList.toggle('active', b === btn));
          els.tabPanels.forEach(panel => {
            panel.classList.toggle('hidden', panel.dataset.tab !== tab);
          });
        });
      });
    }

    function bindSearch() {
      if (!els.searchInput) return;
      els.searchInput.addEventListener('input', () => {
        const term = els.searchInput.value.trim();
        if (!term) {
          els.searchResults.innerHTML = '';
          return;
        }
        renderSearchResults(term);
      });
      els.searchClear.addEventListener('click', () => {
        els.searchInput.value = '';
        els.searchResults.innerHTML = '';
        els.searchInput.focus();
      });
      els.refreshButtons.forEach(btn => {
        btn.addEventListener('click', refreshDashboard);
      });
    }

    function bindMasterForm() {
      if (!els.masterForm) return;
      els.masterForm.addEventListener('submit', evt => {
        evt.preventDefault();
        const formData = new FormData(els.masterForm);
        const payload = Object.fromEntries(formData.entries());
        payload.minimum = Number(payload.minimum || 0);
        payload.qty = Number(payload.qty || 1);
        payload.tags = (payload.tags || '')
          .split(',')
          .map(t => t.trim())
          .filter(Boolean);
        payload.active = true;
        google.script.run
          .withSuccessHandler(result => {
            showToast('ãƒã‚¹ã‚¿ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
            els.masterForm.reset();
            refreshMasters();
          })
          .withFailureHandler(err => {
            els.masterFormMessage.textContent = err.message || err;
            showError(err);
          })
          .createMaster(payload);
      });
      els.masterForm.addEventListener('reset', () => {
        els.masterFormMessage.textContent = '';
      });
    }

    function bindMasterList() {
      if (!els.masterList) return;
      els.masterList.addEventListener('click', evt => {
        const item = evt.target.closest('.master-item');
        if (!item) return;
        const id = item.dataset.id;
        const master = state.masters.find(row => row.id === id);
        if (!master) return;
        openMasterDialog(master);
      });
      els.masterSearch.addEventListener('input', renderMasterList);
      els.masterTagFilter.addEventListener('change', renderMasterList);
      if (els.masterDialog) {
        els.masterDialog.addEventListener('close', () => {
          els.masterEditForm.reset();
        });
      }
      els.masterEditForm.addEventListener('submit', evt => {
        evt.preventDefault();
        saveMasterFromDialog();
      });
      els.masterDelete.addEventListener('click', evt => {
        evt.preventDefault();
        const id = els.masterEditForm.elements['id'].value;
        if (!id) return;
        if (!confirm('æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
        google.script.run
          .withSuccessHandler(() => {
            showToast('ãƒã‚¹ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
            els.masterDialog.close();
            refreshMasters();
          })
          .withFailureHandler(showError)
          .deleteMaster({ id });
      });
    }

    function bindMasterCsv() {
      els.masterExport.addEventListener('click', () => {
        google.script.run
          .withSuccessHandler(result => {
            downloadCsv(result.csv, 'master.csv');
            showToast('ãƒã‚¹ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
          })
          .withFailureHandler(showError)
          .exportMastersCsv();
      });
      els.masterImport.addEventListener('change', evt => {
        const file = evt.target.files && evt.target.files[0];
        if (!file) return;
        readFileText(file)
          .then(text => {
            return new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .importMastersCsv(text);
            });
          })
          .then(() => {
            showToast('ãƒã‚¹ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
            refreshMasters();
          })
          .catch(showError)
          .finally(() => {
            evt.target.value = '';
          });
      });
    }

    function bindConstantsCsv() {
      els.constantsExport.addEventListener('click', () => {
        google.script.run
          .withSuccessHandler(result => {
            downloadCsv(result.csv, 'constants.csv');
            showToast('å•†å“å®šæ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
          })
          .withFailureHandler(showError)
          .exportConstantsCsv();
      });
      els.constantsImport.addEventListener('change', evt => {
        const file = evt.target.files && evt.target.files[0];
        if (!file) return;
        readFileText(file)
          .then(text => {
            return new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .importConstantsCsv(text);
            });
          })
          .then(() => {
            showToast('å•†å“å®šæ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
            refreshConstants();
          })
          .catch(showError)
          .finally(() => {
            evt.target.value = '';
          });
      });
      els.constantsDeficit.addEventListener('click', () => {
        google.script.run
          .withSuccessHandler(result => {
            downloadCsv(result.csv, 'deficit.csv');
            showToast('ä¸è¶³ãƒªã‚¹ãƒˆã‚’å‡ºåŠ›ã—ã¾ã—ãŸ');
          })
          .withFailureHandler(showError)
          .exportDeficitCsv();
      });
    }

    function bindQueueControls() {
      els.flushQueue.addEventListener('click', flushQueue);
      window.addEventListener('online', handleOnline);
      window.addEventListener('offline', handleOffline);
      updateNetworkStatus(navigator.onLine);
    }

    function bindManualInput() {
      els.manualSubmit.addEventListener('click', () => {
        const raw = els.manualCode.value.trim();
        if (!raw) return;
        processScan(raw, {
          processingMessage: 'âŒ¨ï¸ æ‰‹å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ä¸­...',
          processingOverlay: 'âŒ¨ï¸ æ‰‹å…¥åŠ›å‡¦ç†ä¸­â€¦'
        });
        els.manualCode.value = '';
      });
      els.manualCode.addEventListener('keydown', evt => {
        if (evt.key === 'Enter') {
          evt.preventDefault();
          els.manualSubmit.click();
        }
      });
    }

    function bindScanControls() {
      updateCameraHints();
      updateGs1ModeUI();
      if (els.gs1ModeToggle) {
        els.gs1ModeToggle.addEventListener('click', toggleGs1Mode);
      }
    }

    function prepareScanCanvases() {
      if (!state.camera.frameCanvas) {
        state.camera.frameCanvas = document.createElement('canvas');
        state.camera.frameContext = state.camera.frameCanvas.getContext('2d', {
          willReadFrequently: true
        });
      }
      if (!state.camera.roiCanvas) {
        state.camera.roiCanvas = document.createElement('canvas');
        state.camera.roiContext = state.camera.roiCanvas.getContext('2d', {
          willReadFrequently: true
        });
      }
      if (!state.camera.rotateCanvas90) {
        state.camera.rotateCanvas90 = document.createElement('canvas');
        state.camera.rotateContext90 = state.camera.rotateCanvas90.getContext('2d', {
          willReadFrequently: true
        });
      }
      if (!state.camera.rotateCanvas270) {
        state.camera.rotateCanvas270 = document.createElement('canvas');
        state.camera.rotateContext270 = state.camera.rotateCanvas270.getContext('2d', {
          willReadFrequently: true
        });
      }
    }

    function toggleGs1Mode() {
      state.camera.gs1Mode = !state.camera.gs1Mode;
      updateCameraHints({ restart: true });
      updateGs1ModeUI();
      const toastMessage = state.camera.gs1Mode
        ? 'GS1ãƒªãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸï¼ˆGS1-128/GS1 DataMatrixï¼‰'
        : 'æ±ç”¨ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸ';
      showToast(toastMessage);
      if (state.currentView === 'scan') {
        drawOverlayMessage(
          state.camera.gs1Mode ? 'GS1ãƒªãƒ¼ãƒ€ãƒ¼ ON' : 'GS1ãƒªãƒ¼ãƒ€ãƒ¼ OFF',
          'info',
          state.camera.gs1Mode
            ? 'GS1-128 / GS1 DataMatrix ã‚’å„ªå…ˆã—ã¦èª­ã¿å–ã‚Šã¾ã™'
            : 'JANãƒ»QR ãªã©æ±ç”¨ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’ä½µç”¨ã—ã¾ã™'
        );
        clearScanHint();
        showScanHint(
          state.camera.gs1Mode
            ? 'æ å†…ã§æ°´å¹³ã«ä¿æŒã—ã€GS1 ã®å…ˆé ­ãŒå·¦å´ã«æ¥ã‚‹ã‚ˆã†èª¿æ•´ã—ã¦ãã ã•ã„ã€‚'
            : 'GS1 ãŒèª­ã¿å–ã‚Šã¥ã‚‰ã„å ´åˆã¯å†åº¦ ON ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚'
        );
        scheduleReturnToActive(2000);
      }
    }

    function updateGs1ModeUI() {
      if (els.gs1ModeToggle) {
        els.gs1ModeToggle.textContent = state.camera.gs1Mode ? 'GS1ãƒªãƒ¼ãƒ€ãƒ¼ ON' : 'GS1ãƒªãƒ¼ãƒ€ãƒ¼ OFF';
        els.gs1ModeToggle.setAttribute('aria-pressed', state.camera.gs1Mode ? 'true' : 'false');
      }
      if (els.gs1ModeLabel) {
        els.gs1ModeLabel.textContent = state.camera.gs1Mode
          ? 'GS1-128 / GS1 DataMatrix å„ªå…ˆãƒ¢ãƒ¼ãƒ‰'
          : 'æ±ç”¨ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ‰';
      }
    }

    function bindNetworkEvents() {
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && state.currentView === 'scan') {
          startCamera();
        } else if (document.visibilityState !== 'visible') {
          stopCamera();
        }
      });
    }

    function switchView(name) {
      state.currentView = name;
      els.views.forEach(view => {
        view.classList.toggle('active', view.dataset.view === name);
      });
      document
        .querySelectorAll('.nav-btn')
        .forEach(btn => btn.classList.toggle('active', btn.dataset.target === name));
      if (name === 'scan') {
        startCamera();
      } else {
        stopCamera();
      }
    }

    function refreshDashboard() {
      google.script.run
        .withSuccessHandler(data => {
          state.dashboard = data;
          renderDashboard();
        })
        .withFailureHandler(showError)
        .getDashboardSnapshot();
    }

    function refreshMasters() {
      google.script.run
        .withSuccessHandler(result => {
          state.masters = result.items || [];
          state.tags = collectTags(state.masters);
          renderMasterList();
          populateTagFilter();
        })
        .withFailureHandler(showError)
        .listMasters();
    }

    function refreshConstants() {
      google.script.run
        .withSuccessHandler(result => {
          state.constants = result.items || [];
          renderConstants();
        })
        .withFailureHandler(showError)
        .listConstants();
    }

    function renderDashboard() {
      if (!state.dashboard) return;
      const near = state.dashboard.nearExpiry || {};
      els.badgeExpired.textContent = near.expired || 0;
      els.badgeLt1m.textContent = near.lt1m || 0;
      els.badgeLt2m.textContent = near.lt2m || 0;
      renderRecentScans(state.dashboard.latestScans || []);
    }

    function renderRecentScans(scans) {
      els.recentScans.innerHTML = '';
      if (!scans.length) {
        els.recentScans.innerHTML = '<li class="scan-item">å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“</li>';
        return;
      }
      const fragment = document.createDocumentFragment();
      scans.forEach(entry => {
        const li = document.createElement('li');
        li.className = 'scan-item';
        li.innerHTML = `
          <header>
            <span>${escapeHtml(entry.gtin || '---')}</span>
            <span>${escapeHtml(entry.timestamp || '')}</span>
          </header>
          <div>æœŸé™: ${entry.expiry || '-'} / åˆ¤å®š: <span class="status-tag">${entry.status || '-'}</span></div>
          <div>ãƒ¡ãƒ¢: ${escapeHtml(entry.notes || '')}</div>
        `;
        fragment.appendChild(li);
      });
      els.recentScans.appendChild(fragment);
    }

    function renderSearchResults(term) {
      if (!state.dashboard || !state.dashboard.searchIndex) return;
      const normalized = term.toLowerCase();
      const hits = state.dashboard.searchIndex.filter(item => {
        const haystack = [item.name, item.tags.join(','), item.gs1.join(',')]
          .join(' ')
          .toLowerCase();
        return haystack.includes(normalized);
      });
      els.searchResults.innerHTML = '';
      if (!hits.length) {
        els.searchResults.innerHTML = '<li class="search-item">è©²å½“ãŒã‚ã‚Šã¾ã›ã‚“</li>';
        return;
      }
      const fragment = document.createDocumentFragment();
      hits.forEach(hit => {
        const li = document.createElement('li');
        li.className = 'search-item';
        li.innerHTML = `
          <header>${escapeHtml(hit.name)}</header>
          <div>GS1: ${hit.gs1.map(escapeHtml).join(', ')}</div>
          <div>ã‚¿ã‚°: ${hit.tags.map(escapeHtml).join(', ') || '-'}</div>
        `;
        fragment.appendChild(li);
      });
      els.searchResults.appendChild(fragment);
    }

    function collectTags(masters) {
      const set = new Set();
      masters.forEach(item => {
        (item.tags || []).forEach(tag => set.add(tag));
      });
      return Array.from(set).sort();
    }

    function populateTagFilter() {
      const select = els.masterTagFilter;
      const current = select.value;
      select.innerHTML = '<option value="">ã‚¿ã‚°ã§çµã‚Šè¾¼ã¿</option>';
      state.tags.forEach(tag => {
        const opt = document.createElement('option');
        opt.value = tag;
        opt.textContent = tag;
        select.appendChild(opt);
      });
      if (current) {
        select.value = current;
      }
    }

    function renderMasterList() {
      const keyword = (els.masterSearch.value || '').toLowerCase();
      const tag = els.masterTagFilter.value;
      const list = state.masters.filter(item => {
        if (tag && !(item.tags || []).includes(tag)) return false;
        if (!keyword) return true;
        const text = [
          item.name,
          item.gs1,
          item.alt1,
          item.alt2,
          (item.tags || []).join(',')
        ]
          .filter(Boolean)
          .join(' ')
          .toLowerCase();
        return text.includes(keyword);
      });
      els.masterList.innerHTML = '';
      if (!list.length) {
        els.masterList.innerHTML = '<div class="master-item">è©²å½“ã™ã‚‹ãƒã‚¹ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }
      const fragment = document.createDocumentFragment();
      list.forEach(item => {
        const div = document.createElement('div');
        div.className = 'master-item';
        div.dataset.id = item.id;
        div.innerHTML = `
          <header>${escapeHtml(item.name)} ${item.active ? '' : '<span class="tag">ç„¡åŠ¹</span>'}</header>
          <div>GS1: ${escapeHtml(item.gs1)}</div>
          <div>äºˆå‚™: ${escapeHtml(item.alt1 || '-')} / ${escapeHtml(item.alt2 || '-')}</div>
          <div>å®šæ•°: ${item.minimum} / å˜ä½: ${escapeHtml(item.unit)} / QTY: ${item.qty}</div>
          <div class="tags">${(item.tags || []).map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}</div>
        `;
        fragment.appendChild(div);
      });
      els.masterList.appendChild(fragment);
    }

    function openMasterDialog(master) {
      const form = els.masterEditForm;
      form.elements['id'].value = master.id;
      form.elements['name'].value = master.name;
      form.elements['gs1'].value = master.gs1;
      form.elements['alt1'].value = master.alt1 || '';
      form.elements['alt2'].value = master.alt2 || '';
      form.elements['minimum'].value = master.minimum;
      form.elements['unit'].value = master.unit;
      form.elements['qty'].value = master.qty;
      form.elements['tags'].value = (master.tags || []).join(', ');
      form.elements['active'].checked = !!master.active;
      if (typeof els.masterDialog.showModal === 'function') {
        els.masterDialog.showModal();
      }
    }

    function saveMasterFromDialog() {
      const form = els.masterEditForm;
      const payload = {
        id: form.elements['id'].value,
        name: form.elements['name'].value,
        gs1: form.elements['gs1'].value,
        alt1: form.elements['alt1'].value,
        alt2: form.elements['alt2'].value,
        minimum: Number(form.elements['minimum'].value || 0),
        unit: form.elements['unit'].value,
        qty: Number(form.elements['qty'].value || 1),
        tags: form.elements['tags'].value
          .split(',')
          .map(t => t.trim())
          .filter(Boolean),
        active: form.elements['active'].checked
      };
      google.script.run
        .withSuccessHandler(() => {
          showToast('ãƒã‚¹ã‚¿ã‚’æ›´æ–°ã—ã¾ã—ãŸ');
          els.masterDialog.close();
          refreshMasters();
        })
        .withFailureHandler(showError)
        .updateMaster(payload);
    }

    function renderConstants() {
      els.constantsBody.innerHTML = '';
      if (!state.constants.length) {
        els.constantsBody.innerHTML = '<div class="constants-row">ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        return;
      }
      const fragment = document.createDocumentFragment();
      state.constants.forEach(item => {
        const row = document.createElement('div');
        row.className = 'constants-row';
        row.dataset.color = item.color || 'neutral';
        row.innerHTML = `
          <span>${escapeHtml(item.name)}${item.active ? '' : 'ï¼ˆç„¡åŠ¹ï¼‰'}</span>
          <span class="baseline">${item.baseline}</span>
          <span>${item.currentValue} (${item.currentMonth})</span>
          <span>${escapeHtml(item.updatedAt || '')}</span>
        `;
        const editButton = document.createElement('button');
        editButton.className = 'secondary';
        editButton.textContent = 'ç·¨é›†';
        editButton.addEventListener('click', () => openConstantEditor(item));
        row.appendChild(editButton);
        fragment.appendChild(row);
      });
      els.constantsBody.appendChild(fragment);
    }

    function openConstantEditor(item) {
      const month = item.currentMonth;
      const value = prompt(`${item.name} ã® ${month} åœ¨åº«æ•°`, item.currentValue);
      if (value === null) return;
      const num = Number(value);
      if (Number.isNaN(num)) {
        showToast('æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }
      google.script.run
        .withSuccessHandler(() => {
          showToast('å•†å“å®šæ•°ã‚’æ›´æ–°ã—ã¾ã—ãŸ');
          refreshConstants();
        })
        .withFailureHandler(showError)
        .updateConstant({ id: item.id, month, value: num });
    }

    function setScanStage(stage, options = {}) {
      if (state.scan.resetTimer) {
        clearTimeout(state.scan.resetTimer);
        state.scan.resetTimer = null;
      }
      const defaults = {
        idle: { message: 'ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ã™ã‚‹ã¨ã‚¹ã‚­ãƒ£ãƒ³ã§ãã¾ã™', tone: 'muted' },
        initializing: { message: 'ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–ä¸­â€¦', tone: 'info' },
        ready: {
          message: 'ğŸ“· ã‚«ãƒ¡ãƒ©æº–å‚™å®Œäº†ã€‚ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’æ å†…ã«åã‚ã¦ãã ã•ã„',
          tone: 'info'
        },
        active: { message: 'ğŸ” èª­ã¿å–ã‚Šä¸­â€¦', tone: 'info' },
        processing: { message: 'â˜ï¸ èª­ã¿å–ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­â€¦', tone: 'info' },
        success: { message: 'âœ… èª­ã¿å–ã‚Šå®Œäº†', tone: 'success' },
        queued: {
          message: 'ğŸ“¦ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚ã‚­ãƒ¥ãƒ¼ã«ä¿å­˜ã—ã¾ã—ãŸ',
          tone: 'warning'
        },
        error: {
          message: 'âš ï¸ èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸã€‚ä½ç½®ã‚„æ˜ã‚‹ã•ã‚’èª¿æ•´ã—ã¦ãã ã•ã„',
          tone: 'danger'
        }
      };
      const preset = defaults[stage] || {};
      const message = options.message || preset.message || '';
      const tone = options.tone || preset.tone || 'info';
      state.scan.stage = stage;
      updateScanStatus(message, tone);
      if (stage === 'active') {
        syncOverlaySize();
        drawScanReticle();
        scheduleScanHint();
      } else if (stage === 'ready') {
        syncOverlaySize();
        drawScanReticle();
        clearScanHint();
      } else if (stage === 'idle' || stage === 'initializing') {
        clearScanHint();
        clearOverlay();
      } else {
        clearScanHint();
      }
    }

    function updateScanStatus(message, tone) {
      if (!els.scanStatus) return;
      els.scanStatus.textContent = message;
      els.scanStatus.dataset.tone = tone || 'info';
    }

    function scheduleScanHint(delay = 8000) {
      clearScanHintTimer();
      if (state.scan.stage !== 'active') return;
      state.scan.hintTimer = setTimeout(() => {
        const hintMessage =
          'èª­ã¿å–ã‚Šã¥ã‚‰ã„å ´åˆã¯è·é›¢ã‚„è§’åº¦ã€å‘¨å›²ã®æ˜ã‚‹ã•ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚å¿…è¦ã«å¿œã˜ã¦æ‰‹å…¥åŠ›ã‚‚ã”åˆ©ç”¨ã„ãŸã ã‘ã¾ã™ã€‚';
        showScanHint(hintMessage);
      }, delay);
    }

    function showScanHint(text) {
      if (!els.scanHint) return;
      els.scanHint.textContent = text;
      els.scanHint.classList.add('visible');
    }

    function clearScanHint() {
      clearScanHintTimer();
      if (!els.scanHint) return;
      els.scanHint.textContent = '';
      els.scanHint.classList.remove('visible');
    }

    function clearScanHintTimer() {
      if (state.scan.hintTimer) {
        clearTimeout(state.scan.hintTimer);
        state.scan.hintTimer = null;
      }
    }

    function scheduleReturnToActive(delay = 2000) {
      if (state.scan.resetTimer) {
        clearTimeout(state.scan.resetTimer);
      }
      state.scan.resetTimer = setTimeout(() => {
        state.scan.resetTimer = null;
        if (state.currentView === 'scan' && state.camera.stream) {
          setScanStage('active');
        } else {
          setScanStage('idle');
        }
      }, delay);
    }

    function clearScanTimers() {
      clearScanHintTimer();
      if (state.scan.overlayTimer) {
        clearTimeout(state.scan.overlayTimer);
        state.scan.overlayTimer = null;
      }
      if (state.scan.resetTimer) {
        clearTimeout(state.scan.resetTimer);
        state.scan.resetTimer = null;
      }
    }

    function syncOverlaySize() {
      if (!els.cameraOverlay || !els.cameraPreview) return;
      const video = els.cameraPreview;
      const canvas = els.cameraOverlay;
      const width = video.videoWidth || video.clientWidth;
      const height = video.videoHeight || video.clientHeight;
      if (!width || !height) return;
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
      if (state.scan.stage === 'active' || state.scan.stage === 'ready') {
        drawScanReticle();
      }
    }

    function drawScanReticle() {
      if (!els.cameraOverlay) return;
      const canvas = els.cameraOverlay;
      const ctx = canvas.getContext('2d');
      if (!ctx || !canvas.width || !canvas.height) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const region = getScanRegion(canvas.width, canvas.height);
      const maskColor = 'rgba(5, 8, 13, 0.52)';
      ctx.fillStyle = maskColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.clearRect(region.x, region.y, region.width, region.height);
      const lineWidth = Math.max(2, canvas.width * 0.005);
      const corner = Math.min(region.width, region.height) * 0.18;
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      // top-left corner
      ctx.moveTo(region.x, region.y + corner);
      ctx.lineTo(region.x, region.y);
      ctx.lineTo(region.x + corner, region.y);
      // top-right corner
      ctx.moveTo(region.x + region.width - corner, region.y);
      ctx.lineTo(region.x + region.width, region.y);
      ctx.lineTo(region.x + region.width, region.y + corner);
      // bottom-right corner
      ctx.moveTo(region.x + region.width, region.y + region.height - corner);
      ctx.lineTo(region.x + region.width, region.y + region.height);
      ctx.lineTo(region.x + region.width - corner, region.y + region.height);
      // bottom-left corner
      ctx.moveTo(region.x + corner, region.y + region.height);
      ctx.lineTo(region.x, region.y + region.height);
      ctx.lineTo(region.x, region.y + region.height - corner);
      ctx.stroke();
      ctx.setLineDash([lineWidth * 2, lineWidth * 2]);
      ctx.lineDashOffset = 0;
      ctx.beginPath();
      ctx.moveTo(region.x + region.width * 0.5, region.y);
      ctx.lineTo(region.x + region.width * 0.5, region.y + region.height);
      ctx.moveTo(region.x, region.y + region.height * 0.5);
      ctx.lineTo(region.x + region.width, region.y + region.height * 0.5);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.45)';
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawOverlayMessage(title, tone = 'info', subtitle = '') {
      if (!els.cameraOverlay) return;
      const canvas = els.cameraOverlay;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      syncOverlaySize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const toneColors = {
        info: 'rgba(44, 123, 229, 0.75)',
        success: 'rgba(43, 191, 106, 0.78)',
        warning: 'rgba(255, 180, 0, 0.78)',
        caution: 'rgba(249, 214, 92, 0.78)',
        danger: 'rgba(255, 77, 109, 0.78)',
        muted: 'rgba(12, 16, 24, 0.65)'
      };
      const color = toneColors[tone] || toneColors.info;
      const titleText = title && title.length > 28 ? `${title.slice(0, 28)}â€¦` : title;
      const subtitleText = subtitle && subtitle.length > 32 ? `${subtitle.slice(0, 32)}â€¦` : subtitle;
      const boxHeight = subtitleText ? canvas.height * 0.32 : canvas.height * 0.26;
      const top = (canvas.height - boxHeight) / 2;
      ctx.fillStyle = color;
      ctx.fillRect(0, top, canvas.width, boxHeight);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      const baseFont = Math.max(24, canvas.width * 0.06);
      ctx.font = `700 ${baseFont}px "Noto Sans JP", sans-serif`;
      ctx.fillText(titleText, canvas.width / 2, top + boxHeight / 2 - (subtitleText ? baseFont * 0.2 : 0));
      if (subtitleText) {
        const subFont = Math.max(18, canvas.width * 0.04);
        ctx.font = `500 ${subFont}px "Noto Sans JP", sans-serif`;
        ctx.fillText(subtitleText, canvas.width / 2, top + boxHeight / 2 + subFont * 1.1);
      }
      if (state.scan.overlayTimer) {
        clearTimeout(state.scan.overlayTimer);
      }
      state.scan.overlayTimer = setTimeout(() => {
        clearOverlay();
      }, 1800);
    }

    function clearOverlay() {
      if (!els.cameraOverlay) return;
      const ctx = els.cameraOverlay.getContext('2d');
      if (!ctx) return;
      ctx.clearRect(0, 0, els.cameraOverlay.width, els.cameraOverlay.height);
    }

    function ensureActiveScanning() {
      if (state.scan.stage === 'ready' || state.scan.stage === 'initializing') {
        setScanStage('active');
      }
    }

    function handleDecodeLoop(result, err) {
      if (!state.camera.stream) {
        return;
      }
      if (result) {
        handleCameraResult(result.getText());
      } else if (err instanceof ZXing.NotFoundException) {
        ensureActiveScanning();
      } else if (err && !(err instanceof ZXing.NotFoundException)) {
        console.error(err);
      }
    }

    function restartCameraDecoding() {
      if (!state.camera.reader || !state.camera.stream) {
        return;
      }
      try {
        state.camera.reader.reset();
      } catch (err) {
        console.error(err);
      }
      try {
        state.camera.reader.decodeFromVideoElement(
          els.cameraPreview,
          handleDecodeLoop,
          state.camera.hints,
          200
        );
      } catch (err) {
        console.error(err);
      }
    }

    function updateCameraHints(options = {}) {
      if (!window.ZXing || !ZXing.DecodeHintType || !ZXing.BarcodeFormat) {
        state.camera.hints = null;
        return;
      }
      const formats = new Set([
        ZXing.BarcodeFormat.CODE_128,
        ZXing.BarcodeFormat.DATA_MATRIX,
        ZXing.BarcodeFormat.QR_CODE
      ].filter(Boolean));
      const extraFormats = state.camera.gs1Mode
        ? ['RSS_EXPANDED', 'RSS_14', 'RSS_LIMITED']
        : ['EAN_13', 'EAN_8', 'UPC_A', 'UPC_E', 'CODE_39', 'ITF'];
      extraFormats.forEach(name => {
        const fmt = ZXing.BarcodeFormat[name];
        if (fmt) {
          formats.add(fmt);
        }
      });
      const hints = new Map();
      hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, Array.from(formats));
      hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
      hints.set(ZXing.DecodeHintType.ALSO_INVERTED, true);
      hints.set(ZXing.DecodeHintType.CHARACTER_SET, 'UTF-8');
      if (state.camera.gs1Mode) {
        hints.set(ZXing.DecodeHintType.ASSUME_GS1, true);
      }
      state.camera.hints = hints;
      if (window.ZXing && ZXing.MultiFormatReader) {
        if (!state.camera.reader) {
          state.camera.reader = new ZXing.MultiFormatReader();
        }
        if (state.camera.reader && typeof state.camera.reader.setHints === 'function') {
          try {
            state.camera.reader.setHints(hints);
          } catch (err) {
            console.error(err);
          }
        }
      }
      if (options.restart) {
        restartFrameProcessing();
      if (state.camera.reader && typeof state.camera.reader.setHints === 'function') {
        try {
          state.camera.reader.setHints(hints);
        } catch (err) {
          console.error(err);
        }
      }
      if (options.restart) {
        restartCameraDecoding();
      }
    }

    function startCamera() {
      if (state.camera.stream) {
        return;
      }
      if (!navigator.mediaDevices || !window.ZXing) {
        els.scanPlaceholder.textContent = 'ã‚«ãƒ¡ãƒ©ã‚’åˆ©ç”¨ã§ãã¾ã›ã‚“';
        els.scanPlaceholder.classList.remove('hidden');
        setScanStage('error', {
          message: 'ã‚«ãƒ¡ãƒ©æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚å¯¾å¿œç«¯æœ«ã¾ãŸã¯å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ã€‚',
          tone: 'danger'
        });
        return;
      }
      setScanStage('initializing');
      stopCamera(true, true);
      updateCameraHints();
      prepareScanCanvases();
      if (!state.camera.reader) {
        state.camera.reader = new ZXing.BrowserMultiFormatReader(state.camera.hints || undefined);
      } else if (state.camera.hints && typeof state.camera.reader.setHints === 'function') {
        try {
          state.camera.reader.setHints(state.camera.hints);
        } catch (err) {
          console.error(err);
        }
      }
      els.scanPlaceholder.textContent = 'ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–ä¸­â€¦';
      els.scanPlaceholder.classList.remove('hidden');
      const supported = navigator.mediaDevices.getSupportedConstraints
        ? navigator.mediaDevices.getSupportedConstraints()
        : {};
      const videoConstraints = {
        facingMode: { ideal: 'environment' },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      };
      if (supported.focusMode) {
        videoConstraints.focusMode = 'continuous';
      }
      if (supported.torch) {
        videoConstraints.advanced = [{ torch: false }];
      }
      const constraints = {
        video: videoConstraints,
        audio: false
      };
      navigator.mediaDevices
        .getUserMedia(constraints)
        .then(stream => {
          state.camera.stream = stream;
          els.cameraPreview.srcObject = stream;
          return waitForVideo(els.cameraPreview);
        })
        .then(() => {
          els.scanPlaceholder.classList.add('hidden');
          syncOverlaySize();
          setScanStage('ready');
          beginFrameProcessing();
          return state.camera.reader.decodeFromVideoElement(
            els.cameraPreview,
            handleDecodeLoop,
            state.camera.hints,
            200
          );
        })
        .catch(error => {
          stopCamera(false);
          if (error && error.name === 'NotAllowedError') {
            els.scanPlaceholder.textContent = 'ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ã”ç¢ºèªãã ã•ã„ã€‚';
          } else if (error && error.name === 'NotFoundError') {
            els.scanPlaceholder.textContent = 'ã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
          } else {
            els.scanPlaceholder.textContent = 'ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ';
          }
          setScanStage('error', {
            message: 'ã‚«ãƒ¡ãƒ©ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ¨©é™ã‚„ä»–ã®ã‚¢ãƒ—ãƒªã®ä½¿ç”¨çŠ¶æ³ã‚’ã”ç¢ºèªãã ã•ã„ã€‚',
            tone: 'danger'
          });
          showError(error);
        });
    }

    function waitForVideo(video) {
      return new Promise(resolve => {
        const handleLoaded = () => {
          video.removeEventListener('loadeddata', handleLoaded);
          const playPromise = video.play();
          if (playPromise && typeof playPromise.catch === 'function') {
            playPromise.catch(() => {});
          }
          resolve();
        };
        if (video.readyState >= 2) {
          handleLoaded();
        } else {
          video.addEventListener('loadeddata', handleLoaded, { once: true });
        }
      });
    }

    function stopCamera(keepPlaceholder = false, skipStageUpdate = false) {
      if (state.camera.reader) {
        try {
          state.camera.reader.reset();
        } catch (e) {
          console.error(e);
        }
      }
      if (state.camera.stream) {
        state.camera.stream.getTracks().forEach(track => {
          try {
            track.stop();
          } catch (err) {
            console.error(err);
          }
        });
        state.camera.stream = null;
      }
      if (els.cameraPreview) {
        els.cameraPreview.srcObject = null;
      }
      stopFrameProcessing();
      clearScanTimers();
      clearOverlay();
      if (!keepPlaceholder && els.scanPlaceholder) {
        els.scanPlaceholder.classList.remove('hidden');
        els.scanPlaceholder.textContent = 'ã‚«ãƒ¡ãƒ©ã¯åœæ­¢ä¸­ã§ã™';
      }
      if (!skipStageUpdate) {
        setScanStage('idle');
      }
    }

    function handleCameraResult(text) {
      const now = Date.now();
      if (now - state.lastScanTime < 300) {
        return;
      }
      state.lastScanTime = now;
      processScan(text);
      scheduleFrameScan(420);
    }

    function beginFrameProcessing() {
      if (!state.camera.stream || !els.cameraPreview) {
        return;
      }
      if (!window.ZXing || !ZXing.MultiFormatReader) {
        return;
      }
      if (!state.camera.reader) {
        state.camera.reader = new ZXing.MultiFormatReader();
        if (state.camera.hints && state.camera.reader.setHints) {
          try {
            state.camera.reader.setHints(state.camera.hints);
          } catch (err) {
            console.error(err);
          }
        }
      }
      state.scan.frameAttempts = 0;
      setScanStage('active');
      scheduleFrameScan(0);
    }

    function restartFrameProcessing() {
      stopFrameProcessing();
      if (state.camera.stream) {
        if (state.scan.stage === 'active' || state.scan.stage === 'ready') {
          setScanStage('active');
        }
        scheduleFrameScan(120);
      }
    }

    function stopFrameProcessing() {
      if (state.scan.frameHandle) {
        cancelAnimationFrame(state.scan.frameHandle);
        state.scan.frameHandle = null;
      }
      if (state.scan.frameTimer) {
        clearTimeout(state.scan.frameTimer);
        state.scan.frameTimer = null;
      }
      state.scan.frameAttempts = 0;
    }

    function scheduleFrameScan(delay = 0) {
      if (!state.camera.stream || !els.cameraPreview) {
        return;
      }
      if (state.scan.frameHandle) {
        cancelAnimationFrame(state.scan.frameHandle);
        state.scan.frameHandle = null;
      }
      if (state.scan.frameTimer) {
        clearTimeout(state.scan.frameTimer);
        state.scan.frameTimer = null;
      }
      if (delay > 0) {
        state.scan.frameTimer = setTimeout(() => {
          state.scan.frameTimer = null;
          state.scan.frameHandle = requestAnimationFrame(scanFrame);
        }, delay);
      } else {
        state.scan.frameHandle = requestAnimationFrame(scanFrame);
      }
    }

    function scanFrame() {
      state.scan.frameHandle = null;
      if (!state.camera.stream || !els.cameraPreview) {
        return;
      }
      const video = els.cameraPreview;
      if (!video.videoWidth || !video.videoHeight) {
        scheduleFrameScan(120);
        return;
      }
      prepareScanCanvases();
      const frameCanvas = state.camera.frameCanvas;
      const frameCtx = state.camera.frameContext;
      frameCanvas.width = video.videoWidth;
      frameCanvas.height = video.videoHeight;
      frameCtx.drawImage(video, 0, 0, frameCanvas.width, frameCanvas.height);
      const region = getScanRegion(frameCanvas.width, frameCanvas.height);
      const roiCanvas = state.camera.roiCanvas;
      const roiCtx = state.camera.roiContext;
      roiCanvas.width = region.width;
      roiCanvas.height = region.height;
      roiCtx.save();
      roiCtx.filter = 'contrast(140%) brightness(120%)';
      roiCtx.drawImage(
        frameCanvas,
        region.x,
        region.y,
        region.width,
        region.height,
        0,
        0,
        region.width,
        region.height
      );
      roiCtx.restore();
      const rotateCanvas90 = state.camera.rotateCanvas90;
      const rotateCtx90 = state.camera.rotateContext90;
      rotateCanvas90.width = roiCanvas.height;
      rotateCanvas90.height = roiCanvas.width;
      rotateCtx90.save();
      rotateCtx90.clearRect(0, 0, rotateCanvas90.width, rotateCanvas90.height);
      rotateCtx90.translate(rotateCanvas90.width / 2, rotateCanvas90.height / 2);
      rotateCtx90.rotate(Math.PI / 2);
      rotateCtx90.drawImage(roiCanvas, -roiCanvas.width / 2, -roiCanvas.height / 2);
      rotateCtx90.restore();
      const rotateCanvas270 = state.camera.rotateCanvas270;
      const rotateCtx270 = state.camera.rotateContext270;
      rotateCanvas270.width = roiCanvas.height;
      rotateCanvas270.height = roiCanvas.width;
      rotateCtx270.save();
      rotateCtx270.clearRect(0, 0, rotateCanvas270.width, rotateCanvas270.height);
      rotateCtx270.translate(rotateCanvas270.width / 2, rotateCanvas270.height / 2);
      rotateCtx270.rotate(-Math.PI / 2);
      rotateCtx270.drawImage(roiCanvas, -roiCanvas.width / 2, -roiCanvas.height / 2);
      rotateCtx270.restore();
      const result = tryDecodeFromCanvases();
      if (result && result.getText) {
        ensureActiveScanning();
        handleCameraResult(result.getText());
        return;
      }
      state.scan.frameAttempts += 1;
      if (state.scan.frameAttempts > 6) {
        state.scan.frameAttempts = 0;
        ensureActiveScanning();
      }
      scheduleFrameScan(0);
    }

    function getScanRegion(width, height) {
      const portrait = height >= width;
      const regionWidth = portrait ? width * 0.92 : width * 0.7;
      const regionHeight = portrait ? height * 0.42 : height * 0.66;
      const x = Math.max(0, (width - regionWidth) / 2);
      const y = Math.max(0, (height - regionHeight) / 2);
      return {
        x,
        y,
        width: Math.floor(regionWidth),
        height: Math.floor(regionHeight)
      };
    }

    function tryDecodeFromCanvases() {
      if (
        !window.ZXing ||
        !state.camera.reader ||
        !state.camera.roiCanvas ||
        !ZXing.HTMLCanvasElementLuminanceSource ||
        !ZXing.BinaryBitmap
      ) {
        return null;
      }
      const canvases = [
        state.camera.roiCanvas,
        state.camera.rotateCanvas90,
        state.camera.rotateCanvas270,
        state.camera.frameCanvas
      ];
      const attempts = [];
      canvases.forEach(canvas => {
        if (!canvas || !canvas.width || !canvas.height) return;
        try {
          const base = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
          attempts.push(base);
          if (typeof base.invert === 'function') {
            attempts.push(base.invert());
          }
        } catch (err) {
          console.debug(err);
        }
      });
      const binarizers = [ZXing.HybridBinarizer, ZXing.GlobalHistogramBinarizer].filter(Boolean);
      for (const source of attempts) {
        for (const Binarizer of binarizers) {
          try {
            const binary = new ZXing.BinaryBitmap(new Binarizer(source));
            if (state.camera.reader.setHints && state.camera.hints) {
              state.camera.reader.setHints(state.camera.hints);
            }
            const result = state.camera.reader.decodeWithState(binary);
            if (result) {
              state.camera.reader.reset();
              return result;
            }
          } catch (err) {
            if (!(err instanceof ZXing.NotFoundException)) {
              console.debug(err);
            }
          } finally {
            try {
              state.camera.reader.reset();
            } catch (resetErr) {
              console.debug(resetErr);
            }
          }
        }
      }
      return null;
    }

    function processScan(raw, options = {}) {
      const processingMessage = options.processingMessage || 'â˜ï¸ èª­ã¿å–ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­â€¦';
      const processingTone = options.processingTone || 'info';
      const overlayText = options.processingOverlay || 'ğŸ“¤ èª­ã¿å–ã‚Šä¸­â€¦';
      const parsed = parseGs1Data(raw);
      const overlaySubtitle = parsed.summary || (parsed.isGs1 ? parsed.normalized : '');
      setScanStage('processing', { message: processingMessage, tone: processingTone });
      drawOverlayMessage(overlayText, processingTone, overlaySubtitle);
      if (state.camera.gs1Mode && !parsed.isGs1) {
        showScanHint('GS1 ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚æ å†…ã„ã£ã±ã„ã«åã‚ã€æ˜ã‚‹ã•ã¨è§’åº¦ã‚’èª¿æ•´ã—ã¦ãã ã•ã„ã€‚');
      }
      if (!navigator.onLine) {
        queueScan(raw);
        showToast('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚ã‚­ãƒ¥ãƒ¼ã«ä¿å­˜ã—ã¾ã—ãŸ');
        renderQueue();
        setScanStage('queued', {
          message: 'ğŸ“¦ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚ã‚­ãƒ¥ãƒ¼ã«ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ¥ç¶šå¾©å¸°ã§è‡ªå‹•é€ä¿¡ï¼‰',
          tone: 'warning'
        });
        const offlineSubtitle = parsed.summary || 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¾©å¸°å¾Œã«é€ä¿¡ã—ã¾ã™';
        drawOverlayMessage('ğŸ“¦ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ä¿å­˜', 'warning', offlineSubtitle);
        scheduleReturnToActive(2600);
        return;
      }
      google.script.run
        .withSuccessHandler(result => {
          displayScanResult(result);
          presentScanOutcome(result);
          playFeedback(result.status);
          refreshDashboard();
          flushQueue();
        })
        .withFailureHandler(err => {
          showError(err);
          if (!navigator.onLine) {
            queueScan(raw);
            renderQueue();
            setScanStage('queued', {
              message: 'ğŸ“¦ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚ã‚­ãƒ¥ãƒ¼ã«ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ¥ç¶šå¾©å¸°ã§è‡ªå‹•é€ä¿¡ï¼‰',
              tone: 'warning'
            });
            const offlineSubtitle = parsed.summary || 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¾©å¸°å¾Œã«é€ä¿¡ã—ã¾ã™';
            drawOverlayMessage('ğŸ“¦ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ä¿å­˜', 'warning', offlineSubtitle);
            scheduleReturnToActive(2600);
          } else {
            setScanStage('error', {
              message: 'âš ï¸ èª­ã¿å–ã‚Šçµæœã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
              tone: 'danger'
            });
            drawOverlayMessage('âš ï¸ é€ä¿¡å¤±æ•—', 'danger');
            scheduleReturnToActive(2600);
          }
        })
        .recordScan({ raw });
    }

    function displayScanResult(result) {
      const fields = els.resultCard.querySelectorAll('[data-field]');
      const map = {
        name: result.master ? result.master.name : 'æœªç™»éŒ²',
        expiry: result.parsed && result.parsed.expiryIso ? result.parsed.expiryIso : '-'
      };
      if (result.status) {
        map.status = `${result.status.icon || result.status} ${result.status.label || ''}`;
      } else {
        map.status = '-';
      }
      map.lot = result.parsed && result.parsed.lot ? result.parsed.lot : '-';
      map.serial = result.parsed && result.parsed.serial ? result.parsed.serial : '-';
      fields.forEach(field => {
        const key = field.dataset.field;
        field.textContent = map[key] || '-';
      });
      els.resultCard.dataset.status = result.status ? result.status.code : '';
    }

    function presentScanOutcome(result) {
      const status = result.status || {};
      const toneMap = {
        expired: 'danger',
        lt1m: 'warning',
        lt2m: 'caution',
        ok: 'success',
        'no-data': 'info'
      };
      const tone = toneMap[status.code] || 'info';
      const icon = status.icon || 'âœ…';
      const label = status.label || 'èª­ã¿å–ã‚Šå®Œäº†';
      const product = result.master ? result.master.name : 'ãƒã‚¹ã‚¿æœªç™»éŒ²ã®å•†å“';
      const overlayProduct = product && product.length > 24 ? `${product.slice(0, 24)}â€¦` : product;
      setScanStage('success', {
        message: `${icon} ${label} - æ¬¡ã®ãƒãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã£ã¦ãã ã•ã„`,
        tone: tone
      });
      drawOverlayMessage(`${icon} ${label}`, tone, overlayProduct);
      scheduleReturnToActive(2200);
    }

    function playFeedback(status) {
      try {
        if ('vibrate' in navigator) {
          navigator.vibrate([60, 40, 60]);
        }
      } catch (e) {
        console.debug(e);
      }
      if (!window.AudioContext) return;
      try {
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const freqMap = {
          expired: 220,
          lt1m: 320,
          lt2m: 420,
          ok: 520,
          'no-data': 380
        };
        const freq = status && freqMap[status.code] ? freqMap[status.code] : 500;
        osc.frequency.value = freq;
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(ctx.destination);
        gain.gain.setValueAtTime(0.0001, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.3);
        osc.start();
        osc.stop(ctx.currentTime + 0.32);
      } catch (err) {
        console.debug(err);
      }
    }

    function parseGs1Data(raw) {
      const result = {
        raw: raw || '',
        normalized: '',
        segments: [],
        data: {},
        summary: '',
        errors: [],
        isGs1: false
      };
      if (!raw) {
        result.errors.push('EMPTY');
        return result;
      }
      let input = String(raw).trim();
      if (!input) {
        result.errors.push('EMPTY');
        return result;
      }
      if (/^\]C.*/i.test(input)) {
        input = input.replace(/^\]C.\s*/, '');
      }
      result.normalized = input.replace(/\s+/g, '');
      const canonical = result.normalized;
      const segments = [];
      const seen = new Set();
      const pushSegment = (ai, value) => {
        if (!ai || value === undefined || value === null) return;
        const spec = GS1_AI_SPECS[ai] || { variable: true, key: `ai${ai}`, label: `AI${ai}` };
        const processed = normalizeGs1Value(ai, value, spec);
        segments.push({ ai, value: processed.value, label: spec.label || `AI${ai}` });
        if (spec.key && !seen.has(spec.key)) {
          result.data[spec.key] = processed.coerced;
          seen.add(spec.key);
        } else if (!spec.key) {
          result.data[`ai${ai}`] = processed.coerced;
        }
        if (processed.error) {
          result.errors.push(processed.error);
        }
      };

      if (canonical.includes('(') && canonical.includes(')')) {
        // Parenthesis-style input such as (01)...(17) from manual entry; this follows
        // the extraction approach used by libraries like PeterBrockfeld/BarcodeParser.
        const regex = /\((\d{2,4})\)([^()]*)/g;
        let match;
        while ((match = regex.exec(canonical)) !== null) {
          const ai = match[1];
          const spec = GS1_AI_SPECS[ai];
          let value = match[2] || '';
          if (spec && spec.length) {
            value = value.slice(0, spec.length);
          }
          pushSegment(ai, value);
        }
      } else {
        let cursor = 0;
        while (cursor < canonical.length) {
          if (canonical[cursor] === GS1_FNC1) {
            cursor += 1;
            continue;
          }
          const ai = matchGs1Ai(canonical, cursor);
          if (!ai) {
            result.errors.push(`UNKNOWN_AI:${canonical.slice(cursor, cursor + 4)}`);
            break;
          }
          cursor += ai.length;
          const spec = GS1_AI_SPECS[ai];
          let value = '';
          if (spec && spec.length) {
            value = canonical.slice(cursor, cursor + spec.length);
            cursor += value.length;
            if (value.length < spec.length) {
              result.errors.push(`SHORT_${ai}`);
            }
          } else {
            let end = canonical.indexOf(GS1_FNC1, cursor);
            if (end === -1) {
              end = canonical.length;
            }
            value = canonical.slice(cursor, end);
            if (spec && spec.max && value.length > spec.max) {
              value = value.slice(0, spec.max);
              result.errors.push(`TRUNCATED_${ai}`);
              cursor = cursor + spec.max;
            } else {
              cursor = end;
            }
          }
          pushSegment(ai, value);
          if (canonical[cursor] === GS1_FNC1) {
            cursor += 1;
          }
        }
      }

      if (!segments.length) {
        return result;
      }

      result.segments = segments;
      result.isGs1 = true;
      result.summary = buildGs1Summary(result.data, segments);
      return result;
    }

    function matchGs1Ai(source, start) {
      const maxLen = Math.min(4, source.length - start);
      for (let len = maxLen; len >= 2; len--) {
        const candidate = source.slice(start, start + len);
        if (GS1_AI_SPECS[candidate]) {
          return candidate;
        }
        if (len > 2 && /^\d{3,4}$/.test(candidate)) {
          return candidate;
        }
      }
      const fallback = source.slice(start, start + 2);
      return /^\d{2}$/.test(fallback) ? fallback : null;
    }

    function normalizeGs1Value(ai, raw, spec = {}) {
      let value = String(raw || '').replace(/\s+/g, '');
      if (!value) {
        const needsValue = spec.min && spec.min > 0;
        return { value: '', coerced: '', error: needsValue ? `EMPTY_${ai}` : null };
      }
      if (spec.length && value.length > spec.length) {
        value = value.slice(0, spec.length);
      }
      if (spec.variable && spec.max && value.length > spec.max) {
        value = value.slice(0, spec.max);
      }
      if (spec.type === 'date') {
        const iso = convertGs1Date(value);
        return {
          value: iso || value,
          coerced: iso || value,
          error: iso ? null : `DATE_${ai}`
        };
      }
      if (spec.key === 'gtin' && value.length === 14) {
        return { value, coerced: value };
      }
      return { value, coerced: value };
    }

    function convertGs1Date(value) {
      if (!/^\d{6}$/.test(value)) {
        return null;
      }
      const yy = Number(value.slice(0, 2));
      const mm = Number(value.slice(2, 4));
      const dd = Number(value.slice(4, 6));
      if (Number.isNaN(mm) || mm < 1 || mm > 12) {
        return null;
      }
      const year = 2000 + yy;
      const date = new Date(Date.UTC(year, mm - 1, dd));
      if (
        date.getUTCFullYear() !== year ||
        date.getUTCMonth() !== mm - 1 ||
        date.getUTCDate() !== dd
      ) {
        return null;
      }
      return `${year}-${String(mm).padStart(2, '0')}-${String(dd).padStart(2, '0')}`;
    }

    function buildGs1Summary(data, segments) {
      const parts = [];
      if (data.gtin) {
        parts.push(`GTIN ${data.gtin}`);
      }
      if (data.expiry) {
        parts.push(`æœŸé™ ${data.expiry}`);
      } else if (data.bestBefore) {
        parts.push(`è³å‘³æœŸé™ ${data.bestBefore}`);
      }
      if (data.lot) {
        parts.push(`ãƒ­ãƒƒãƒˆ ${data.lot}`);
      }
      if (data.serial) {
        parts.push(`ã‚·ãƒªã‚¢ãƒ« ${data.serial}`);
      }
      if (!parts.length && segments.length) {
        const first = segments[0];
        parts.push(`${first.label || `AI${first.ai}`} ${first.value}`);
      }
      return parts.join(' / ');
    }

    function queueScan(raw) {
      const parsed = parseGs1Data(raw);
      state.offlineQueue.push({ raw, parsed, timestamp: new Date().toISOString() });
      saveQueue();
    }

    function flushQueue() {
      if (!state.offlineQueue.length || !navigator.onLine) {
        return;
      }
      const queue = [...state.offlineQueue];
      const next = () => {
        if (!queue.length) {
          state.offlineQueue = [];
          saveQueue();
          renderQueue();
          showToast('ã‚­ãƒ¥ãƒ¼ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
          refreshDashboard();
          return;
        }
        const item = queue.shift();
        google.script.run
          .withSuccessHandler(() => {
            state.offlineQueue.shift();
            saveQueue();
            renderQueue();
            next();
          })
          .withFailureHandler(err => {
            showError(err);
            renderQueue();
          })
          .recordScan({ raw: item.raw });
      };
      next();
    }

    function renderQueue() {
      els.queueList.innerHTML = '';
      if (!state.offlineQueue.length) {
        els.queueList.innerHTML = '<li class="queue-item">ã‚­ãƒ¥ãƒ¼ã¯ç©ºã§ã™</li>';
        return;
      }
      const fragment = document.createDocumentFragment();
      let mutated = false;
      state.offlineQueue.forEach(item => {
        const li = document.createElement('li');
        li.className = 'queue-item';
        const parsed = item.parsed || parseGs1Data(item.raw);
        if (!item.parsed) {
          item.parsed = parsed;
          mutated = true;
        }
        const summary = parsed && parsed.summary ? `ï¼ˆ${parsed.summary}ï¼‰` : '';
        li.textContent = `${item.timestamp} : ${item.raw}${summary}`;
        fragment.appendChild(li);
      });
      els.queueList.appendChild(fragment);
      if (mutated) {
        saveQueue();
      }
    }

    function handleOnline() {
      updateNetworkStatus(true);
      flushQueue();
    }

    function handleOffline() {
      updateNetworkStatus(false);
      showToast('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã—ãŸ');
    }

    function updateNetworkStatus(isOnline) {
      if (!els.networkStatus) return;
      if (isOnline) {
        els.networkStatus.textContent = 'ğŸ”Œ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³';
        els.networkStatus.classList.remove('offline');
      } else {
        els.networkStatus.textContent = 'âš ï¸ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
        els.networkStatus.classList.add('offline');
      }
    }

    function readFileText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, 'UTF-8');
      });
    }

    function downloadCsv(text, filename) {
      const blob = new Blob([text], { type: 'text/csv;charset=UTF-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function showToast(message) {
      if (!els.toast) return;
      els.toast.textContent = message;
      els.toast.classList.add('active');
      setTimeout(() => {
        els.toast.classList.remove('active');
      }, 2400);
    }

    function showError(error) {
      const message = (error && error.message) || error || 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      console.error(message);
      showToast(message);
    }

    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function loadQueue() {
      try {
        const text = localStorage.getItem('gs1-offline-queue');
        if (!text) return [];
        const parsed = JSON.parse(text);
        if (!Array.isArray(parsed)) {
          return [];
        }
        return parsed.map(item => {
          if (!item || typeof item !== 'object') {
            return null;
          }
          if (!item.parsed && item.raw) {
            item.parsed = parseGs1Data(item.raw);
          }
          return item;
        }).filter(Boolean);
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    function saveQueue() {
      try {
        localStorage.setItem('gs1-offline-queue', JSON.stringify(state.offlineQueue));
      } catch (e) {
        console.error(e);
      }
    }

    window.addEventListener('load', init);
  })();
</script>
